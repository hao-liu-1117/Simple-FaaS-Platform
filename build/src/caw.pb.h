// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caw.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_caw_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_caw_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_caw_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_caw_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_caw_2eproto;
namespace caw {
class Caw;
class CawDefaultTypeInternal;
extern CawDefaultTypeInternal _Caw_default_instance_;
class CawReply;
class CawReplyDefaultTypeInternal;
extern CawReplyDefaultTypeInternal _CawReply_default_instance_;
class CawRequest;
class CawRequestDefaultTypeInternal;
extern CawRequestDefaultTypeInternal _CawRequest_default_instance_;
class FollowReply;
class FollowReplyDefaultTypeInternal;
extern FollowReplyDefaultTypeInternal _FollowReply_default_instance_;
class FollowRequest;
class FollowRequestDefaultTypeInternal;
extern FollowRequestDefaultTypeInternal _FollowRequest_default_instance_;
class ProfileReply;
class ProfileReplyDefaultTypeInternal;
extern ProfileReplyDefaultTypeInternal _ProfileReply_default_instance_;
class ProfileRequest;
class ProfileRequestDefaultTypeInternal;
extern ProfileRequestDefaultTypeInternal _ProfileRequest_default_instance_;
class ReadReply;
class ReadReplyDefaultTypeInternal;
extern ReadReplyDefaultTypeInternal _ReadReply_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class RegisteruserReply;
class RegisteruserReplyDefaultTypeInternal;
extern RegisteruserReplyDefaultTypeInternal _RegisteruserReply_default_instance_;
class RegisteruserRequest;
class RegisteruserRequestDefaultTypeInternal;
extern RegisteruserRequestDefaultTypeInternal _RegisteruserRequest_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace caw
PROTOBUF_NAMESPACE_OPEN
template<> ::caw::Caw* Arena::CreateMaybeMessage<::caw::Caw>(Arena*);
template<> ::caw::CawReply* Arena::CreateMaybeMessage<::caw::CawReply>(Arena*);
template<> ::caw::CawRequest* Arena::CreateMaybeMessage<::caw::CawRequest>(Arena*);
template<> ::caw::FollowReply* Arena::CreateMaybeMessage<::caw::FollowReply>(Arena*);
template<> ::caw::FollowRequest* Arena::CreateMaybeMessage<::caw::FollowRequest>(Arena*);
template<> ::caw::ProfileReply* Arena::CreateMaybeMessage<::caw::ProfileReply>(Arena*);
template<> ::caw::ProfileRequest* Arena::CreateMaybeMessage<::caw::ProfileRequest>(Arena*);
template<> ::caw::ReadReply* Arena::CreateMaybeMessage<::caw::ReadReply>(Arena*);
template<> ::caw::ReadRequest* Arena::CreateMaybeMessage<::caw::ReadRequest>(Arena*);
template<> ::caw::RegisteruserReply* Arena::CreateMaybeMessage<::caw::RegisteruserReply>(Arena*);
template<> ::caw::RegisteruserRequest* Arena::CreateMaybeMessage<::caw::RegisteruserRequest>(Arena*);
template<> ::caw::Timestamp* Arena::CreateMaybeMessage<::caw::Timestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace caw {

// ===================================================================

class Timestamp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Timestamp& default_instance();

  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kUsecondsFieldNumber = 2,
  };
  // int64 seconds = 1;
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::int64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 useconds = 2;
  void clear_useconds();
  ::PROTOBUF_NAMESPACE_ID::int64 useconds() const;
  void set_useconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_useconds() const;
  void _internal_set_useconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:caw.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 seconds_;
  ::PROTOBUF_NAMESPACE_ID::int64 useconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class Caw PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.Caw) */ {
 public:
  inline Caw() : Caw(nullptr) {}
  virtual ~Caw();

  Caw(const Caw& from);
  Caw(Caw&& from) noexcept
    : Caw() {
    *this = ::std::move(from);
  }

  inline Caw& operator=(const Caw& from) {
    CopyFrom(from);
    return *this;
  }
  inline Caw& operator=(Caw&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Caw& default_instance();

  static inline const Caw* internal_default_instance() {
    return reinterpret_cast<const Caw*>(
               &_Caw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Caw& a, Caw& b) {
    a.Swap(&b);
  }
  inline void Swap(Caw* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Caw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Caw* New() const final {
    return CreateMaybeMessage<Caw>(nullptr);
  }

  Caw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Caw>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Caw& from);
  void MergeFrom(const Caw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Caw* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.Caw";
  }
  protected:
  explicit Caw(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kTextFieldNumber = 2,
    kIdFieldNumber = 3,
    kParentIdFieldNumber = 4,
    kTimestampFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bytes id = 3;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes parent_id = 4;
  void clear_parent_id();
  const std::string& parent_id() const;
  void set_parent_id(const std::string& value);
  void set_parent_id(std::string&& value);
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  std::string* mutable_parent_id();
  std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // .caw.Timestamp timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::caw::Timestamp& timestamp() const;
  ::caw::Timestamp* release_timestamp();
  ::caw::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::caw::Timestamp* timestamp);
  private:
  const ::caw::Timestamp& _internal_timestamp() const;
  ::caw::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::caw::Timestamp* timestamp);
  ::caw::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:caw.Caw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  ::caw::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class RegisteruserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.RegisteruserRequest) */ {
 public:
  inline RegisteruserRequest() : RegisteruserRequest(nullptr) {}
  virtual ~RegisteruserRequest();

  RegisteruserRequest(const RegisteruserRequest& from);
  RegisteruserRequest(RegisteruserRequest&& from) noexcept
    : RegisteruserRequest() {
    *this = ::std::move(from);
  }

  inline RegisteruserRequest& operator=(const RegisteruserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisteruserRequest& operator=(RegisteruserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisteruserRequest& default_instance();

  static inline const RegisteruserRequest* internal_default_instance() {
    return reinterpret_cast<const RegisteruserRequest*>(
               &_RegisteruserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisteruserRequest& a, RegisteruserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisteruserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisteruserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisteruserRequest* New() const final {
    return CreateMaybeMessage<RegisteruserRequest>(nullptr);
  }

  RegisteruserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisteruserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisteruserRequest& from);
  void MergeFrom(const RegisteruserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisteruserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.RegisteruserRequest";
  }
  protected:
  explicit RegisteruserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:caw.RegisteruserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class RegisteruserReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.RegisteruserReply) */ {
 public:
  inline RegisteruserReply() : RegisteruserReply(nullptr) {}
  virtual ~RegisteruserReply();

  RegisteruserReply(const RegisteruserReply& from);
  RegisteruserReply(RegisteruserReply&& from) noexcept
    : RegisteruserReply() {
    *this = ::std::move(from);
  }

  inline RegisteruserReply& operator=(const RegisteruserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisteruserReply& operator=(RegisteruserReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisteruserReply& default_instance();

  static inline const RegisteruserReply* internal_default_instance() {
    return reinterpret_cast<const RegisteruserReply*>(
               &_RegisteruserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisteruserReply& a, RegisteruserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisteruserReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisteruserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisteruserReply* New() const final {
    return CreateMaybeMessage<RegisteruserReply>(nullptr);
  }

  RegisteruserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisteruserReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisteruserReply& from);
  void MergeFrom(const RegisteruserReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisteruserReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.RegisteruserReply";
  }
  protected:
  explicit RegisteruserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:caw.RegisteruserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class CawRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.CawRequest) */ {
 public:
  inline CawRequest() : CawRequest(nullptr) {}
  virtual ~CawRequest();

  CawRequest(const CawRequest& from);
  CawRequest(CawRequest&& from) noexcept
    : CawRequest() {
    *this = ::std::move(from);
  }

  inline CawRequest& operator=(const CawRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CawRequest& operator=(CawRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CawRequest& default_instance();

  static inline const CawRequest* internal_default_instance() {
    return reinterpret_cast<const CawRequest*>(
               &_CawRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CawRequest& a, CawRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CawRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CawRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CawRequest* New() const final {
    return CreateMaybeMessage<CawRequest>(nullptr);
  }

  CawRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CawRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CawRequest& from);
  void MergeFrom(const CawRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CawRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.CawRequest";
  }
  protected:
  explicit CawRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kTextFieldNumber = 2,
    kParentIdFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bytes parent_id = 3;
  void clear_parent_id();
  const std::string& parent_id() const;
  void set_parent_id(const std::string& value);
  void set_parent_id(std::string&& value);
  void set_parent_id(const char* value);
  void set_parent_id(const void* value, size_t size);
  std::string* mutable_parent_id();
  std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // @@protoc_insertion_point(class_scope:caw.CawRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class CawReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.CawReply) */ {
 public:
  inline CawReply() : CawReply(nullptr) {}
  virtual ~CawReply();

  CawReply(const CawReply& from);
  CawReply(CawReply&& from) noexcept
    : CawReply() {
    *this = ::std::move(from);
  }

  inline CawReply& operator=(const CawReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CawReply& operator=(CawReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CawReply& default_instance();

  static inline const CawReply* internal_default_instance() {
    return reinterpret_cast<const CawReply*>(
               &_CawReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CawReply& a, CawReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CawReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CawReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CawReply* New() const final {
    return CreateMaybeMessage<CawReply>(nullptr);
  }

  CawReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CawReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CawReply& from);
  void MergeFrom(const CawReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CawReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.CawReply";
  }
  protected:
  explicit CawReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCawFieldNumber = 1,
  };
  // .caw.Caw caw = 1;
  bool has_caw() const;
  private:
  bool _internal_has_caw() const;
  public:
  void clear_caw();
  const ::caw::Caw& caw() const;
  ::caw::Caw* release_caw();
  ::caw::Caw* mutable_caw();
  void set_allocated_caw(::caw::Caw* caw);
  private:
  const ::caw::Caw& _internal_caw() const;
  ::caw::Caw* _internal_mutable_caw();
  public:
  void unsafe_arena_set_allocated_caw(
      ::caw::Caw* caw);
  ::caw::Caw* unsafe_arena_release_caw();

  // @@protoc_insertion_point(class_scope:caw.CawReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::caw::Caw* caw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class FollowRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.FollowRequest) */ {
 public:
  inline FollowRequest() : FollowRequest(nullptr) {}
  virtual ~FollowRequest();

  FollowRequest(const FollowRequest& from);
  FollowRequest(FollowRequest&& from) noexcept
    : FollowRequest() {
    *this = ::std::move(from);
  }

  inline FollowRequest& operator=(const FollowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowRequest& operator=(FollowRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FollowRequest& default_instance();

  static inline const FollowRequest* internal_default_instance() {
    return reinterpret_cast<const FollowRequest*>(
               &_FollowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FollowRequest& a, FollowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowRequest* New() const final {
    return CreateMaybeMessage<FollowRequest>(nullptr);
  }

  FollowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FollowRequest& from);
  void MergeFrom(const FollowRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.FollowRequest";
  }
  protected:
  explicit FollowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kToFollowFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string to_follow = 2;
  void clear_to_follow();
  const std::string& to_follow() const;
  void set_to_follow(const std::string& value);
  void set_to_follow(std::string&& value);
  void set_to_follow(const char* value);
  void set_to_follow(const char* value, size_t size);
  std::string* mutable_to_follow();
  std::string* release_to_follow();
  void set_allocated_to_follow(std::string* to_follow);
  private:
  const std::string& _internal_to_follow() const;
  void _internal_set_to_follow(const std::string& value);
  std::string* _internal_mutable_to_follow();
  public:

  // @@protoc_insertion_point(class_scope:caw.FollowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_follow_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class FollowReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.FollowReply) */ {
 public:
  inline FollowReply() : FollowReply(nullptr) {}
  virtual ~FollowReply();

  FollowReply(const FollowReply& from);
  FollowReply(FollowReply&& from) noexcept
    : FollowReply() {
    *this = ::std::move(from);
  }

  inline FollowReply& operator=(const FollowReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowReply& operator=(FollowReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FollowReply& default_instance();

  static inline const FollowReply* internal_default_instance() {
    return reinterpret_cast<const FollowReply*>(
               &_FollowReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FollowReply& a, FollowReply& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowReply* New() const final {
    return CreateMaybeMessage<FollowReply>(nullptr);
  }

  FollowReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FollowReply& from);
  void MergeFrom(const FollowReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.FollowReply";
  }
  protected:
  explicit FollowReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:caw.FollowReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {}
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadRequest& default_instance();

  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return CreateMaybeMessage<ReadRequest>(nullptr);
  }

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCawIdFieldNumber = 1,
  };
  // bytes caw_id = 1;
  void clear_caw_id();
  const std::string& caw_id() const;
  void set_caw_id(const std::string& value);
  void set_caw_id(std::string&& value);
  void set_caw_id(const char* value);
  void set_caw_id(const void* value, size_t size);
  std::string* mutable_caw_id();
  std::string* release_caw_id();
  void set_allocated_caw_id(std::string* caw_id);
  private:
  const std::string& _internal_caw_id() const;
  void _internal_set_caw_id(const std::string& value);
  std::string* _internal_mutable_caw_id();
  public:

  // @@protoc_insertion_point(class_scope:caw.ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caw_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class ReadReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.ReadReply) */ {
 public:
  inline ReadReply() : ReadReply(nullptr) {}
  virtual ~ReadReply();

  ReadReply(const ReadReply& from);
  ReadReply(ReadReply&& from) noexcept
    : ReadReply() {
    *this = ::std::move(from);
  }

  inline ReadReply& operator=(const ReadReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadReply& operator=(ReadReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadReply& default_instance();

  static inline const ReadReply* internal_default_instance() {
    return reinterpret_cast<const ReadReply*>(
               &_ReadReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadReply& a, ReadReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadReply* New() const final {
    return CreateMaybeMessage<ReadReply>(nullptr);
  }

  ReadReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadReply& from);
  void MergeFrom(const ReadReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.ReadReply";
  }
  protected:
  explicit ReadReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCawsFieldNumber = 1,
  };
  // repeated .caw.Caw caws = 1;
  int caws_size() const;
  private:
  int _internal_caws_size() const;
  public:
  void clear_caws();
  ::caw::Caw* mutable_caws(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caw::Caw >*
      mutable_caws();
  private:
  const ::caw::Caw& _internal_caws(int index) const;
  ::caw::Caw* _internal_add_caws();
  public:
  const ::caw::Caw& caws(int index) const;
  ::caw::Caw* add_caws();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caw::Caw >&
      caws() const;

  // @@protoc_insertion_point(class_scope:caw.ReadReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caw::Caw > caws_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class ProfileRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.ProfileRequest) */ {
 public:
  inline ProfileRequest() : ProfileRequest(nullptr) {}
  virtual ~ProfileRequest();

  ProfileRequest(const ProfileRequest& from);
  ProfileRequest(ProfileRequest&& from) noexcept
    : ProfileRequest() {
    *this = ::std::move(from);
  }

  inline ProfileRequest& operator=(const ProfileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileRequest& operator=(ProfileRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProfileRequest& default_instance();

  static inline const ProfileRequest* internal_default_instance() {
    return reinterpret_cast<const ProfileRequest*>(
               &_ProfileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProfileRequest& a, ProfileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileRequest* New() const final {
    return CreateMaybeMessage<ProfileRequest>(nullptr);
  }

  ProfileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProfileRequest& from);
  void MergeFrom(const ProfileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.ProfileRequest";
  }
  protected:
  explicit ProfileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:caw.ProfileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// -------------------------------------------------------------------

class ProfileReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caw.ProfileReply) */ {
 public:
  inline ProfileReply() : ProfileReply(nullptr) {}
  virtual ~ProfileReply();

  ProfileReply(const ProfileReply& from);
  ProfileReply(ProfileReply&& from) noexcept
    : ProfileReply() {
    *this = ::std::move(from);
  }

  inline ProfileReply& operator=(const ProfileReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileReply& operator=(ProfileReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProfileReply& default_instance();

  static inline const ProfileReply* internal_default_instance() {
    return reinterpret_cast<const ProfileReply*>(
               &_ProfileReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProfileReply& a, ProfileReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileReply* New() const final {
    return CreateMaybeMessage<ProfileReply>(nullptr);
  }

  ProfileReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProfileReply& from);
  void MergeFrom(const ProfileReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caw.ProfileReply";
  }
  protected:
  explicit ProfileReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caw_2eproto);
    return ::descriptor_table_caw_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFollowersFieldNumber = 1,
    kFollowingFieldNumber = 2,
  };
  // repeated string followers = 1;
  int followers_size() const;
  private:
  int _internal_followers_size() const;
  public:
  void clear_followers();
  const std::string& followers(int index) const;
  std::string* mutable_followers(int index);
  void set_followers(int index, const std::string& value);
  void set_followers(int index, std::string&& value);
  void set_followers(int index, const char* value);
  void set_followers(int index, const char* value, size_t size);
  std::string* add_followers();
  void add_followers(const std::string& value);
  void add_followers(std::string&& value);
  void add_followers(const char* value);
  void add_followers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& followers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_followers();
  private:
  const std::string& _internal_followers(int index) const;
  std::string* _internal_add_followers();
  public:

  // repeated string following = 2;
  int following_size() const;
  private:
  int _internal_following_size() const;
  public:
  void clear_following();
  const std::string& following(int index) const;
  std::string* mutable_following(int index);
  void set_following(int index, const std::string& value);
  void set_following(int index, std::string&& value);
  void set_following(int index, const char* value);
  void set_following(int index, const char* value, size_t size);
  std::string* add_following();
  void add_following(const std::string& value);
  void add_following(std::string&& value);
  void add_following(const char* value);
  void add_following(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& following() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_following();
  private:
  const std::string& _internal_following(int index) const;
  std::string* _internal_add_following();
  public:

  // @@protoc_insertion_point(class_scope:caw.ProfileReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> followers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> following_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_caw_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:caw.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seconds_ = value;
}
inline void Timestamp::set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:caw.Timestamp.seconds)
}

// int64 useconds = 2;
inline void Timestamp::clear_useconds() {
  useconds_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::_internal_useconds() const {
  return useconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::useconds() const {
  // @@protoc_insertion_point(field_get:caw.Timestamp.useconds)
  return _internal_useconds();
}
inline void Timestamp::_internal_set_useconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  useconds_ = value;
}
inline void Timestamp::set_useconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_useconds(value);
  // @@protoc_insertion_point(field_set:caw.Timestamp.useconds)
}

// -------------------------------------------------------------------

// Caw

// string username = 1;
inline void Caw::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& Caw::username() const {
  // @@protoc_insertion_point(field_get:caw.Caw.username)
  return _internal_username();
}
inline void Caw::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:caw.Caw.username)
}
inline std::string* Caw::mutable_username() {
  // @@protoc_insertion_point(field_mutable:caw.Caw.username)
  return _internal_mutable_username();
}
inline const std::string& Caw::_internal_username() const {
  return username_.Get();
}
inline void Caw::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Caw::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.Caw.username)
}
inline void Caw::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.Caw.username)
}
inline void Caw::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.Caw.username)
}
inline std::string* Caw::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Caw::release_username() {
  // @@protoc_insertion_point(field_release:caw.Caw.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Caw::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.Caw.username)
}

// string text = 2;
inline void Caw::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Caw::text() const {
  // @@protoc_insertion_point(field_get:caw.Caw.text)
  return _internal_text();
}
inline void Caw::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:caw.Caw.text)
}
inline std::string* Caw::mutable_text() {
  // @@protoc_insertion_point(field_mutable:caw.Caw.text)
  return _internal_mutable_text();
}
inline const std::string& Caw::_internal_text() const {
  return text_.Get();
}
inline void Caw::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Caw::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.Caw.text)
}
inline void Caw::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.Caw.text)
}
inline void Caw::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.Caw.text)
}
inline std::string* Caw::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Caw::release_text() {
  // @@protoc_insertion_point(field_release:caw.Caw.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Caw::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.Caw.text)
}

// bytes id = 3;
inline void Caw::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Caw::id() const {
  // @@protoc_insertion_point(field_get:caw.Caw.id)
  return _internal_id();
}
inline void Caw::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:caw.Caw.id)
}
inline std::string* Caw::mutable_id() {
  // @@protoc_insertion_point(field_mutable:caw.Caw.id)
  return _internal_mutable_id();
}
inline const std::string& Caw::_internal_id() const {
  return id_.Get();
}
inline void Caw::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Caw::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.Caw.id)
}
inline void Caw::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.Caw.id)
}
inline void Caw::set_id(const void* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.Caw.id)
}
inline std::string* Caw::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Caw::release_id() {
  // @@protoc_insertion_point(field_release:caw.Caw.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Caw::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.Caw.id)
}

// bytes parent_id = 4;
inline void Caw::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& Caw::parent_id() const {
  // @@protoc_insertion_point(field_get:caw.Caw.parent_id)
  return _internal_parent_id();
}
inline void Caw::set_parent_id(const std::string& value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:caw.Caw.parent_id)
}
inline std::string* Caw::mutable_parent_id() {
  // @@protoc_insertion_point(field_mutable:caw.Caw.parent_id)
  return _internal_mutable_parent_id();
}
inline const std::string& Caw::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void Caw::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Caw::set_parent_id(std::string&& value) {
  
  parent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.Caw.parent_id)
}
inline void Caw::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.Caw.parent_id)
}
inline void Caw::set_parent_id(const void* value,
    size_t size) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.Caw.parent_id)
}
inline std::string* Caw::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Caw::release_parent_id() {
  // @@protoc_insertion_point(field_release:caw.Caw.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Caw::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.Caw.parent_id)
}

// .caw.Timestamp timestamp = 5;
inline bool Caw::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Caw::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Caw::clear_timestamp() {
  if (GetArena() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
inline const ::caw::Timestamp& Caw::_internal_timestamp() const {
  const ::caw::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::caw::Timestamp&>(
      ::caw::_Timestamp_default_instance_);
}
inline const ::caw::Timestamp& Caw::timestamp() const {
  // @@protoc_insertion_point(field_get:caw.Caw.timestamp)
  return _internal_timestamp();
}
inline void Caw::unsafe_arena_set_allocated_timestamp(
    ::caw::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:caw.Caw.timestamp)
}
inline ::caw::Timestamp* Caw::release_timestamp() {
  
  ::caw::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::caw::Timestamp* Caw::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:caw.Caw.timestamp)
  
  ::caw::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::caw::Timestamp* Caw::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::caw::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::caw::Timestamp* Caw::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:caw.Caw.timestamp)
  return _internal_mutable_timestamp();
}
inline void Caw::set_allocated_timestamp(::caw::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete timestamp_;
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:caw.Caw.timestamp)
}

// -------------------------------------------------------------------

// RegisteruserRequest

// string username = 1;
inline void RegisteruserRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& RegisteruserRequest::username() const {
  // @@protoc_insertion_point(field_get:caw.RegisteruserRequest.username)
  return _internal_username();
}
inline void RegisteruserRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:caw.RegisteruserRequest.username)
}
inline std::string* RegisteruserRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:caw.RegisteruserRequest.username)
  return _internal_mutable_username();
}
inline const std::string& RegisteruserRequest::_internal_username() const {
  return username_.Get();
}
inline void RegisteruserRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RegisteruserRequest::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.RegisteruserRequest.username)
}
inline void RegisteruserRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.RegisteruserRequest.username)
}
inline void RegisteruserRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.RegisteruserRequest.username)
}
inline std::string* RegisteruserRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RegisteruserRequest::release_username() {
  // @@protoc_insertion_point(field_release:caw.RegisteruserRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegisteruserRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.RegisteruserRequest.username)
}

// -------------------------------------------------------------------

// RegisteruserReply

// -------------------------------------------------------------------

// CawRequest

// string username = 1;
inline void CawRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& CawRequest::username() const {
  // @@protoc_insertion_point(field_get:caw.CawRequest.username)
  return _internal_username();
}
inline void CawRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:caw.CawRequest.username)
}
inline std::string* CawRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:caw.CawRequest.username)
  return _internal_mutable_username();
}
inline const std::string& CawRequest::_internal_username() const {
  return username_.Get();
}
inline void CawRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CawRequest::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.CawRequest.username)
}
inline void CawRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.CawRequest.username)
}
inline void CawRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.CawRequest.username)
}
inline std::string* CawRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CawRequest::release_username() {
  // @@protoc_insertion_point(field_release:caw.CawRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CawRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.CawRequest.username)
}

// string text = 2;
inline void CawRequest::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& CawRequest::text() const {
  // @@protoc_insertion_point(field_get:caw.CawRequest.text)
  return _internal_text();
}
inline void CawRequest::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:caw.CawRequest.text)
}
inline std::string* CawRequest::mutable_text() {
  // @@protoc_insertion_point(field_mutable:caw.CawRequest.text)
  return _internal_mutable_text();
}
inline const std::string& CawRequest::_internal_text() const {
  return text_.Get();
}
inline void CawRequest::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CawRequest::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.CawRequest.text)
}
inline void CawRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.CawRequest.text)
}
inline void CawRequest::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.CawRequest.text)
}
inline std::string* CawRequest::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CawRequest::release_text() {
  // @@protoc_insertion_point(field_release:caw.CawRequest.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CawRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.CawRequest.text)
}

// bytes parent_id = 3;
inline void CawRequest::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& CawRequest::parent_id() const {
  // @@protoc_insertion_point(field_get:caw.CawRequest.parent_id)
  return _internal_parent_id();
}
inline void CawRequest::set_parent_id(const std::string& value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:caw.CawRequest.parent_id)
}
inline std::string* CawRequest::mutable_parent_id() {
  // @@protoc_insertion_point(field_mutable:caw.CawRequest.parent_id)
  return _internal_mutable_parent_id();
}
inline const std::string& CawRequest::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void CawRequest::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CawRequest::set_parent_id(std::string&& value) {
  
  parent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.CawRequest.parent_id)
}
inline void CawRequest::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.CawRequest.parent_id)
}
inline void CawRequest::set_parent_id(const void* value,
    size_t size) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.CawRequest.parent_id)
}
inline std::string* CawRequest::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CawRequest::release_parent_id() {
  // @@protoc_insertion_point(field_release:caw.CawRequest.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CawRequest::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.CawRequest.parent_id)
}

// -------------------------------------------------------------------

// CawReply

// .caw.Caw caw = 1;
inline bool CawReply::_internal_has_caw() const {
  return this != internal_default_instance() && caw_ != nullptr;
}
inline bool CawReply::has_caw() const {
  return _internal_has_caw();
}
inline void CawReply::clear_caw() {
  if (GetArena() == nullptr && caw_ != nullptr) {
    delete caw_;
  }
  caw_ = nullptr;
}
inline const ::caw::Caw& CawReply::_internal_caw() const {
  const ::caw::Caw* p = caw_;
  return p != nullptr ? *p : reinterpret_cast<const ::caw::Caw&>(
      ::caw::_Caw_default_instance_);
}
inline const ::caw::Caw& CawReply::caw() const {
  // @@protoc_insertion_point(field_get:caw.CawReply.caw)
  return _internal_caw();
}
inline void CawReply::unsafe_arena_set_allocated_caw(
    ::caw::Caw* caw) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caw_);
  }
  caw_ = caw;
  if (caw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:caw.CawReply.caw)
}
inline ::caw::Caw* CawReply::release_caw() {
  
  ::caw::Caw* temp = caw_;
  caw_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::caw::Caw* CawReply::unsafe_arena_release_caw() {
  // @@protoc_insertion_point(field_release:caw.CawReply.caw)
  
  ::caw::Caw* temp = caw_;
  caw_ = nullptr;
  return temp;
}
inline ::caw::Caw* CawReply::_internal_mutable_caw() {
  
  if (caw_ == nullptr) {
    auto* p = CreateMaybeMessage<::caw::Caw>(GetArena());
    caw_ = p;
  }
  return caw_;
}
inline ::caw::Caw* CawReply::mutable_caw() {
  // @@protoc_insertion_point(field_mutable:caw.CawReply.caw)
  return _internal_mutable_caw();
}
inline void CawReply::set_allocated_caw(::caw::Caw* caw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete caw_;
  }
  if (caw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(caw);
    if (message_arena != submessage_arena) {
      caw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caw, submessage_arena);
    }
    
  } else {
    
  }
  caw_ = caw;
  // @@protoc_insertion_point(field_set_allocated:caw.CawReply.caw)
}

// -------------------------------------------------------------------

// FollowRequest

// string username = 1;
inline void FollowRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& FollowRequest::username() const {
  // @@protoc_insertion_point(field_get:caw.FollowRequest.username)
  return _internal_username();
}
inline void FollowRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:caw.FollowRequest.username)
}
inline std::string* FollowRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:caw.FollowRequest.username)
  return _internal_mutable_username();
}
inline const std::string& FollowRequest::_internal_username() const {
  return username_.Get();
}
inline void FollowRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FollowRequest::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.FollowRequest.username)
}
inline void FollowRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.FollowRequest.username)
}
inline void FollowRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.FollowRequest.username)
}
inline std::string* FollowRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FollowRequest::release_username() {
  // @@protoc_insertion_point(field_release:caw.FollowRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FollowRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.FollowRequest.username)
}

// string to_follow = 2;
inline void FollowRequest::clear_to_follow() {
  to_follow_.ClearToEmpty();
}
inline const std::string& FollowRequest::to_follow() const {
  // @@protoc_insertion_point(field_get:caw.FollowRequest.to_follow)
  return _internal_to_follow();
}
inline void FollowRequest::set_to_follow(const std::string& value) {
  _internal_set_to_follow(value);
  // @@protoc_insertion_point(field_set:caw.FollowRequest.to_follow)
}
inline std::string* FollowRequest::mutable_to_follow() {
  // @@protoc_insertion_point(field_mutable:caw.FollowRequest.to_follow)
  return _internal_mutable_to_follow();
}
inline const std::string& FollowRequest::_internal_to_follow() const {
  return to_follow_.Get();
}
inline void FollowRequest::_internal_set_to_follow(const std::string& value) {
  
  to_follow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FollowRequest::set_to_follow(std::string&& value) {
  
  to_follow_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.FollowRequest.to_follow)
}
inline void FollowRequest::set_to_follow(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_follow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.FollowRequest.to_follow)
}
inline void FollowRequest::set_to_follow(const char* value,
    size_t size) {
  
  to_follow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.FollowRequest.to_follow)
}
inline std::string* FollowRequest::_internal_mutable_to_follow() {
  
  return to_follow_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FollowRequest::release_to_follow() {
  // @@protoc_insertion_point(field_release:caw.FollowRequest.to_follow)
  return to_follow_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FollowRequest::set_allocated_to_follow(std::string* to_follow) {
  if (to_follow != nullptr) {
    
  } else {
    
  }
  to_follow_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_follow,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.FollowRequest.to_follow)
}

// -------------------------------------------------------------------

// FollowReply

// -------------------------------------------------------------------

// ReadRequest

// bytes caw_id = 1;
inline void ReadRequest::clear_caw_id() {
  caw_id_.ClearToEmpty();
}
inline const std::string& ReadRequest::caw_id() const {
  // @@protoc_insertion_point(field_get:caw.ReadRequest.caw_id)
  return _internal_caw_id();
}
inline void ReadRequest::set_caw_id(const std::string& value) {
  _internal_set_caw_id(value);
  // @@protoc_insertion_point(field_set:caw.ReadRequest.caw_id)
}
inline std::string* ReadRequest::mutable_caw_id() {
  // @@protoc_insertion_point(field_mutable:caw.ReadRequest.caw_id)
  return _internal_mutable_caw_id();
}
inline const std::string& ReadRequest::_internal_caw_id() const {
  return caw_id_.Get();
}
inline void ReadRequest::_internal_set_caw_id(const std::string& value) {
  
  caw_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ReadRequest::set_caw_id(std::string&& value) {
  
  caw_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.ReadRequest.caw_id)
}
inline void ReadRequest::set_caw_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  caw_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.ReadRequest.caw_id)
}
inline void ReadRequest::set_caw_id(const void* value,
    size_t size) {
  
  caw_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.ReadRequest.caw_id)
}
inline std::string* ReadRequest::_internal_mutable_caw_id() {
  
  return caw_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ReadRequest::release_caw_id() {
  // @@protoc_insertion_point(field_release:caw.ReadRequest.caw_id)
  return caw_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReadRequest::set_allocated_caw_id(std::string* caw_id) {
  if (caw_id != nullptr) {
    
  } else {
    
  }
  caw_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caw_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.ReadRequest.caw_id)
}

// -------------------------------------------------------------------

// ReadReply

// repeated .caw.Caw caws = 1;
inline int ReadReply::_internal_caws_size() const {
  return caws_.size();
}
inline int ReadReply::caws_size() const {
  return _internal_caws_size();
}
inline void ReadReply::clear_caws() {
  caws_.Clear();
}
inline ::caw::Caw* ReadReply::mutable_caws(int index) {
  // @@protoc_insertion_point(field_mutable:caw.ReadReply.caws)
  return caws_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caw::Caw >*
ReadReply::mutable_caws() {
  // @@protoc_insertion_point(field_mutable_list:caw.ReadReply.caws)
  return &caws_;
}
inline const ::caw::Caw& ReadReply::_internal_caws(int index) const {
  return caws_.Get(index);
}
inline const ::caw::Caw& ReadReply::caws(int index) const {
  // @@protoc_insertion_point(field_get:caw.ReadReply.caws)
  return _internal_caws(index);
}
inline ::caw::Caw* ReadReply::_internal_add_caws() {
  return caws_.Add();
}
inline ::caw::Caw* ReadReply::add_caws() {
  // @@protoc_insertion_point(field_add:caw.ReadReply.caws)
  return _internal_add_caws();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caw::Caw >&
ReadReply::caws() const {
  // @@protoc_insertion_point(field_list:caw.ReadReply.caws)
  return caws_;
}

// -------------------------------------------------------------------

// ProfileRequest

// string username = 1;
inline void ProfileRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ProfileRequest::username() const {
  // @@protoc_insertion_point(field_get:caw.ProfileRequest.username)
  return _internal_username();
}
inline void ProfileRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:caw.ProfileRequest.username)
}
inline std::string* ProfileRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:caw.ProfileRequest.username)
  return _internal_mutable_username();
}
inline const std::string& ProfileRequest::_internal_username() const {
  return username_.Get();
}
inline void ProfileRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ProfileRequest::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:caw.ProfileRequest.username)
}
inline void ProfileRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:caw.ProfileRequest.username)
}
inline void ProfileRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:caw.ProfileRequest.username)
}
inline std::string* ProfileRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ProfileRequest::release_username() {
  // @@protoc_insertion_point(field_release:caw.ProfileRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProfileRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:caw.ProfileRequest.username)
}

// -------------------------------------------------------------------

// ProfileReply

// repeated string followers = 1;
inline int ProfileReply::_internal_followers_size() const {
  return followers_.size();
}
inline int ProfileReply::followers_size() const {
  return _internal_followers_size();
}
inline void ProfileReply::clear_followers() {
  followers_.Clear();
}
inline std::string* ProfileReply::add_followers() {
  // @@protoc_insertion_point(field_add_mutable:caw.ProfileReply.followers)
  return _internal_add_followers();
}
inline const std::string& ProfileReply::_internal_followers(int index) const {
  return followers_.Get(index);
}
inline const std::string& ProfileReply::followers(int index) const {
  // @@protoc_insertion_point(field_get:caw.ProfileReply.followers)
  return _internal_followers(index);
}
inline std::string* ProfileReply::mutable_followers(int index) {
  // @@protoc_insertion_point(field_mutable:caw.ProfileReply.followers)
  return followers_.Mutable(index);
}
inline void ProfileReply::set_followers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caw.ProfileReply.followers)
  followers_.Mutable(index)->assign(value);
}
inline void ProfileReply::set_followers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caw.ProfileReply.followers)
  followers_.Mutable(index)->assign(std::move(value));
}
inline void ProfileReply::set_followers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caw.ProfileReply.followers)
}
inline void ProfileReply::set_followers(int index, const char* value, size_t size) {
  followers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caw.ProfileReply.followers)
}
inline std::string* ProfileReply::_internal_add_followers() {
  return followers_.Add();
}
inline void ProfileReply::add_followers(const std::string& value) {
  followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caw.ProfileReply.followers)
}
inline void ProfileReply::add_followers(std::string&& value) {
  followers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caw.ProfileReply.followers)
}
inline void ProfileReply::add_followers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caw.ProfileReply.followers)
}
inline void ProfileReply::add_followers(const char* value, size_t size) {
  followers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caw.ProfileReply.followers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProfileReply::followers() const {
  // @@protoc_insertion_point(field_list:caw.ProfileReply.followers)
  return followers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProfileReply::mutable_followers() {
  // @@protoc_insertion_point(field_mutable_list:caw.ProfileReply.followers)
  return &followers_;
}

// repeated string following = 2;
inline int ProfileReply::_internal_following_size() const {
  return following_.size();
}
inline int ProfileReply::following_size() const {
  return _internal_following_size();
}
inline void ProfileReply::clear_following() {
  following_.Clear();
}
inline std::string* ProfileReply::add_following() {
  // @@protoc_insertion_point(field_add_mutable:caw.ProfileReply.following)
  return _internal_add_following();
}
inline const std::string& ProfileReply::_internal_following(int index) const {
  return following_.Get(index);
}
inline const std::string& ProfileReply::following(int index) const {
  // @@protoc_insertion_point(field_get:caw.ProfileReply.following)
  return _internal_following(index);
}
inline std::string* ProfileReply::mutable_following(int index) {
  // @@protoc_insertion_point(field_mutable:caw.ProfileReply.following)
  return following_.Mutable(index);
}
inline void ProfileReply::set_following(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caw.ProfileReply.following)
  following_.Mutable(index)->assign(value);
}
inline void ProfileReply::set_following(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caw.ProfileReply.following)
  following_.Mutable(index)->assign(std::move(value));
}
inline void ProfileReply::set_following(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  following_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caw.ProfileReply.following)
}
inline void ProfileReply::set_following(int index, const char* value, size_t size) {
  following_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caw.ProfileReply.following)
}
inline std::string* ProfileReply::_internal_add_following() {
  return following_.Add();
}
inline void ProfileReply::add_following(const std::string& value) {
  following_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caw.ProfileReply.following)
}
inline void ProfileReply::add_following(std::string&& value) {
  following_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caw.ProfileReply.following)
}
inline void ProfileReply::add_following(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  following_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caw.ProfileReply.following)
}
inline void ProfileReply::add_following(const char* value, size_t size) {
  following_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caw.ProfileReply.following)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProfileReply::following() const {
  // @@protoc_insertion_point(field_list:caw.ProfileReply.following)
  return following_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProfileReply::mutable_following() {
  // @@protoc_insertion_point(field_mutable_list:caw.ProfileReply.following)
  return &following_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_caw_2eproto
